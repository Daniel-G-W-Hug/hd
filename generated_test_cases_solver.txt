////////////////////////////////////////////////////////////////////////////////
// Generated Test Cases for hd_solver.hpp
// Generated by generate_test_solver.py
// Reference implementation: NumPy (numpy.linalg.solve)
////////////////////////////////////////////////////////////////////////////////
================================================================================
Basic Test Cases
================================================================================

// Simple 2x2 system
// Matrix size: 2x2
// Determinant: 5.000000e+00
// Condition number: 2.618034e+00
// Eigenvalues: min=1.381966e+00, max=3.618034e+00
// Eigenvalue ratio: 2.618034e+00

        SUBCASE("Simple 2x2 system")
        {
            // Matrix A
            std::array m_s{2.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 3.0000000000000000e+00};
            // Right-hand side b
            std::array rhs_s{5.0000000000000000e+00, 6.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{1.8000000000000000e+00, 1.3999999999999999e+00};
            std::array<int, 2> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 2, 2>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 2>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 2>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 2; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

// Upper triangular 3x3 system
// Matrix size: 3x3
// Determinant: 4.000000e+00
// Condition number: 1.501797e+01
// Eigenvalues: min=1.000000e+00, max=4.000000e+00
// Eigenvalue ratio: 4.000000e+00

        SUBCASE("Upper triangular 3x3 system")
        {
            // Matrix A
            std::array m_s{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00, 0.0000000000000000e+00, 4.0000000000000000e+00, 1.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 1.0000000000000000e+00};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{-2.0000000000000000e+00, 0.0000000000000000e+00, 1.0000000000000000e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

// General 4x4 system
// Matrix size: 4x4
// Determinant: 8.000000e+00
// Condition number: 1.042765e+02
// Eigenvalues: min=2.523568e-01, max=1.776675e+01
// Eigenvalue ratio: 7.040329e+01

        SUBCASE("General 4x4 system")
        {
            // Matrix A
            std::array m_s{2.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 0.0000000000000000e+00, 4.0000000000000000e+00, 3.0000000000000000e+00, 3.0000000000000000e+00, 1.0000000000000000e+00, 8.0000000000000000e+00, 7.0000000000000000e+00, 9.0000000000000000e+00, 5.0000000000000000e+00, 6.0000000000000000e+00, 7.0000000000000000e+00, 9.0000000000000000e+00, 8.0000000000000000e+00};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00, 4.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{1.0000000000000007e+00, 4.9999999999999922e-01, -1.5000000000000002e+00, 1.0000000000000004e+00};
            std::array<int, 4> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 4, 4>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 4>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 4>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 4; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

// Random 5x5 diagonally dominant system
// Matrix size: 5x5
// Determinant: 3.933353e+05
// Condition number: 3.406669e+00
// Eigenvalues: min=8.333402e+00, max=1.855912e+01
// Eigenvalue ratio: 2.227076e+00

        SUBCASE("Random 5x5 diagonally dominant system")
        {
            // Matrix A
            std::array m_s{1.3508079731285591e+01, 4.5071430640991617e+00, 2.3199394181140507e+00, 9.8658484197036600e-01, -3.4398135955756350e+00, -3.4400547966379733e+00, 1.5612856028097871e+01, 3.6617614577493516e+00, 1.0111501174320880e+00, 2.0807257779604549e+00, -4.7941550570419755e+00, 4.6990985216199430e+00, 1.9876039207812369e+01, -2.8766088932172384e+00, -3.1817503279289938e+00, -3.1659549014656618e+00, -1.9575775704046228e+00, 2.4756431632237841e-01, 9.1393551997910869e+00, -2.0877085980195806e+00, 1.1185289472237947e+00, -3.6050613934795814e+00, -2.0785535146478185e+00, -1.3363815670630830e+00, 9.5778255802439194e+00};
            // Right-hand side b
            std::array rhs_s{5.7035192278602720e+00, -6.0065243568328057e+00, 2.8468876827223211e-01, 1.8482913772408494e+00, -9.0709917456000451e+00};
            // Expected solution x
            std::array x_expected{2.2416392347316735e-01, -1.8161927088157226e-01, -5.7090973775457202e-02, 1.8212694490425936e-03, -1.0537576460766331e+00};
            std::array<int, 5> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 5, 5>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 5>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 5>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 5; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-10);
            }
        }

================================================================================
Identity and Diagonal Matrix Tests
================================================================================

// Identity 3x3
// Matrix size: 3x3
// Determinant: 1.000000e+00
// Condition number: 1.000000e+00
// Eigenvalues: min=1.000000e+00, max=1.000000e+00
// Eigenvalue ratio: 1.000000e+00

        SUBCASE("Identity 3x3")
        {
            // Matrix A
            std::array m_s{1.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 1.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 1.0000000000000000e+00};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

// Diagonal 4x4
// Matrix size: 4x4
// Determinant: 1.200000e+02
// Condition number: 2.500000e+00
// Eigenvalues: min=2.000000e+00, max=5.000000e+00
// Eigenvalue ratio: 2.500000e+00

        SUBCASE("Diagonal 4x4")
        {
            // Matrix A
            std::array m_s{2.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 3.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 4.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 5.0000000000000000e+00};
            // Right-hand side b
            std::array rhs_s{2.0000000000000000e+00, 6.0000000000000000e+00, 1.2000000000000000e+01, 2.0000000000000000e+01};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00, 4.0000000000000000e+00};
            std::array<int, 4> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 4, 4>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 4>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 4>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 4; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

================================================================================
Symmetric Positive Definite Systems
================================================================================

// Symmetric positive definite 3x3
// Matrix size: 3x3
// Determinant: 4.330284e+00
// Condition number: 2.799266e+00
// Eigenvalues: min=1.081935e+00, max=3.028625e+00
// Eigenvalue ratio: 2.799266e+00

        SUBCASE("Symmetric positive definite 3x3")
        {
            // Matrix A
            std::array m_s{2.4588399791620290e+00, 7.0919365619106389e-01, 4.2507946826226545e-01, 7.0919365619106389e-01, 1.7595445552758471e+00, 2.3164588162890817e-01, 4.2507946826226545e-01, 2.3164588162890817e-01, 1.2136829276467180e+00};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{-2.7565413706301506e-01, 9.3307997761344041e-01, 2.3902707320663010e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

// Symmetric positive definite 4x4
// Matrix size: 4x4
// Determinant: 3.418507e-01
// Condition number: 6.033990e+01
// Eigenvalues: min=1.069420e-01, max=6.452872e+00
// Eigenvalue ratio: 6.033990e+01

        SUBCASE("Symmetric positive definite 4x4")
        {
            // Matrix A
            std::array m_s{2.6423491600080413e+00, 9.4504101139848318e-01, 2.0131778941146559e+00, 1.6626426068779672e+00, 9.4504101139848318e-01, 1.2074981056618288e+00, 1.2442162099601155e+00, 1.1045332769598888e+00, 2.0131778941146559e+00, 1.2442162099601155e+00, 2.0492862612307410e+00, 1.5375459906200610e+00, 1.6626426068779672e+00, 1.1045332769598888e+00, 1.5375459906200610e+00, 2.0979381334626752e+00};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{5.4592409300252620e-01, 1.2206796988264754e+00, -7.5599242455463356e-01, -4.4608028332488482e-02};
            std::array<int, 4> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 4, 4>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 4>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 4>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 4; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

================================================================================
Known Solution Tests (x = [1, 2, 3, ...])
================================================================================

// System with known solution [1, 2, 3]
// Matrix size: 3x3
// Determinant: 1.629050e+03
// Condition number: 1.834380e+00
// Eigenvalues: min=8.075643e+00, max=1.420295e+01
// Eigenvalue ratio: 1.758739e+00

        SUBCASE("Known solution [1, 2, 3]")
        {
            // Matrix A
            std::array m_s{9.5877383705702144e+00, -2.7897765828645458e+00, -1.3091874747062171e+00, -2.0922429623358232e+00, 1.2501928016909789e+01, 2.8204643296019594e+00, 3.1109436596485125e+00, -9.9209459226326047e-01, 1.3843046225796916e+01};
            // Right-hand side b
            std::array rhs_s{8.0622780722471532e-02, 3.1373006060289633e+01, 4.2655893152512739e+01};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

// System with known solution [1, 2, 3, 4, 5]
// Matrix size: 5x5
// Determinant: 1.373951e+06
// Condition number: 2.570369e+00
// Eigenvalues: min=1.196377e+01, max=2.493582e+01
// Eigenvalue ratio: 2.084279e+00

        SUBCASE("Known solution [1, 2, 3, 4, 5]")
        {
            // Matrix A
            std::array m_s{1.1789179686688364e+01, 9.3577483579539855e-01, 1.7443171778243318e+00, 3.0533382994044089e-01, 2.1765538292506754e+00, -4.8813115642716820e-01, 1.8418848856402594e+01, 4.3014811323513165e+00, 2.5177375036567806e+00, 2.1593055511210677e+00, -1.2431717738680472e+00, 2.0977271713267251e+00, 1.7977442966843281e+01, -4.9019374691040420e+00, 1.6539630619336210e+00, -2.8156676057111394e+00, 2.8632421604980154e+00, -4.9995222333008460e+00, 2.3117345902954831e+01, 4.6999745345480584e+00, 4.0586543748679578e+00, 4.9501655995457554e+00, 3.7669227607320188e-01, -1.0724686570888142e+00, 1.7515461069223619e+01};
            // Right-hand side b
            std::array rhs_s{3.0997785357767295e+01, 7.0121487723664430e+01, 4.5546676902567185e+01, 1.0388150629994198e+02, 9.8376493119941912e+01};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00, 4.0000000000000000e+00, 5.0000000000000000e+00};
            std::array<int, 5> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 5, 5>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 5>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 5>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 5; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-12);
            }
        }

================================================================================
Stiff System Tests (High Condition Number)
================================================================================

// Stiff 3x3 system (condition number ~ 1e5)
// Matrix size: 3x3
// Determinant: 1.000000e-05
// Condition number: 1.000000e+05
// Eigenvalues: min=1.000000e-05, max=1.000000e+00
// Eigenvalue ratio: 1.000000e+05

        SUBCASE("Stiff 3x3 system (condition ~ 1e5)")
        {
            // Matrix A
            std::array m_s{5.3776159744917407e-01, -3.7263294589470008e-01, -3.3123122891402995e-01, -3.7263294589470008e-01, 6.9960238785894846e-01, -2.6702166657168941e-01, -3.3123122891402995e-01, -2.6702166657168941e-01, 7.6264601469187854e-01};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{2.2012079810630938e+05, 1.7745131698763746e+05, 1.5773665179679994e+05};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-8);
            }
        }

// Stiff 4x4 system (condition number ~ 1e6)
// Matrix size: 4x4
// Determinant: 1.000000e-09
// Condition number: 1.000000e+06
// Eigenvalues: min=1.000000e-06, max=1.000000e+00
// Eigenvalue ratio: 1.000000e+06

        SUBCASE("Stiff 4x4 system (condition ~ 1e6)")
        {
            // Matrix A
            std::array m_s{5.1314778913290296e-02, 1.5744421971936451e-01, -8.4505307859177162e-02, -8.4667879081335426e-02, 1.5744421971936451e-01, 6.1897841926006081e-01, -3.4305278315154170e-01, -3.0380133722697245e-01, -8.4505307859177162e-02, -3.4305278315154170e-01, 2.2367464517359603e-01, 1.2139594510620659e-01, -8.4667879081335426e-02, -3.0380133722697245e-01, 1.2139594510620659e-01, 2.1603315665305281e-01};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{2.8383739938337455e+05, 1.0376112390695130e+06, 1.2176944531361356e+06, 8.8614834193811391e+05};
            std::array<int, 4> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 4, 4>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 4>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 4>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 4; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-6);
            }
        }

// Extremely stiff 5x5 system (condition number ~ 1e7)
// Matrix size: 5x5
// Determinant: 1.000000e-13
// Condition number: 1.000000e+07
// Eigenvalues: min=1.000000e-07, max=1.000000e+00
// Eigenvalue ratio: 1.000000e+07

        SUBCASE("Extremely stiff 5x5 system (condition ~ 1e7)")
        {
            // Matrix A
            std::array m_s{5.9825229513747823e-02, -7.0298469306777106e-02, -2.0150850699421921e-02, 3.1161290382682337e-03, 1.4609377045611561e-02, -7.0298469306777106e-02, 5.2271405811799376e-01, -2.5480685926807155e-02, 1.7225839728373088e-01, -4.4895006245308017e-01, -2.0150850699421921e-02, -2.5480685926807155e-02, 2.2664060958292324e-02, -2.7441171982104454e-02, 4.6245946073636926e-02, 3.1161290382682337e-03, 1.7225839728373088e-01, -2.7441171982104454e-02, 7.5339684044410410e-02, -1.7482365368685723e-01, 1.4609377045611565e-02, -4.4895006245308017e-01, 4.6245946073636926e-02, -1.7482365368685723e-01, 4.3045706736555595e-01};
            // Right-hand side b
            std::array rhs_s{1.0000000000000000e+00, 2.0000000000000000e+00, 3.0000000000000000e+00, 4.0000000000000000e+00, 5.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{6.8792483903377242e+06, 5.1293041822084552e+06, 2.8361287414387647e+07, 5.4180260722165041e+07, 2.4073716646470822e+07};
            std::array<int, 5> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 5, 5>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 5>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 5>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 5; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-5);
            }
        }

// Diagonal stiff 3x3 (eigenvalue ratio = 1e7)
// Matrix size: 3x3
// Determinant: 1.000000e-03
// Condition number: 1.000000e+07
// Eigenvalues: min=1.000000e-05, max=1.000000e+02
// Eigenvalue ratio: 1.000000e+07

        SUBCASE("Diagonal stiff 3x3 (eigenvalue ratio = 1e7)")
        {
            // Matrix A
            std::array m_s{1.0000000000000001e-05, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 1.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 0.0000000000000000e+00, 1.0000000000000000e+02};
            // Right-hand side b
            std::array rhs_s{1.0000000000000001e-05, 1.0000000000000000e+00, 1.0000000000000000e+02};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-10);
            }
        }

================================================================================
Numerically Challenging Systems
================================================================================

// Nearly singular 3x3
// Matrix size: 3x3
// Determinant: 1.000000e-20
// Condition number: 8.999955e+10
// Eigenvalues: min=3.333334e-11, max=3.000000e+00
// Eigenvalue ratio: 8.999999e+10

        SUBCASE("Nearly singular 3x3")
        {
            // Matrix A
            std::array m_s{1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000001000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000001000000e+00};
            // Right-hand side b
            std::array rhs_s{3.0000000000000000e+00, 3.0000000001000000e+00, 3.0000000001000000e+00};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-6);
            }
        }

// Mixed scales 3x3
// Matrix size: 3x3
// Determinant: -9.999980e+05
// Condition number: 1.618036e+06
// Eigenvalues: min=6.180334e-01, max=1.000000e+06
// Eigenvalue ratio: 1.618036e+06

        SUBCASE("Mixed scales 3x3")
        {
            // Matrix A
            std::array m_s{1.0000000000000000e+06, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 9.9999999999999995e-07, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00, 1.0000000000000000e+00};
            // Right-hand side b
            std::array rhs_s{1.0000020000000000e+06, 2.0000010000000001e+00, 3.0000000000000000e+00};
            // Expected solution x
            std::array x_expected{1.0000000000000000e+00, 9.9999999999999978e-01, 1.0000000000000002e+00};
            std::array<int, 3> m_perm_s;

            // Setup mdspan views
            auto m = mdspan<double, extents<size_t, 3, 3>>(m_s.data());
            auto rhs = mdspan<double, extents<size_t, 3>>(rhs_s.data());
            auto m_perm = mdspan<int, extents<size_t, 3>>(m_perm_s.data());

            // Solve system
            hd::lu_decomp(m, m_perm);
            hd::lu_backsubs(m, m_perm, rhs);

            // Verify solution
            for (size_t i = 0; i < 3; ++i) {
                CHECK(std::abs(rhs[i] - x_expected[i]) < 1e-6);
            }
        }

================================================================================
Usage Instructions
================================================================================

To use these test cases:

1. Run this script:
   python3 generate_test_solver.py > new_test_cases.txt

2. Copy the relevant test subcases into hd_solver_test.cpp

3. Organize them into appropriate TEST_CASE sections, such as:
   - TEST_CASE("LU solver: basic systems")
   - TEST_CASE("LU solver: identity and diagonal")
   - TEST_CASE("LU solver: symmetric positive definite")
   - TEST_CASE("LU solver: stiff systems")
   - TEST_CASE("LU solver: numerically challenging")
   - TEST_CASE("LU solver: known solutions")

4. Build and run the tests:
   cd build
   cmake ..
   make hd_solver_test
   ./hd_solver_test

Notes:
- All test cases use NumPy's solver as a reference
- Epsilon values are adjusted based on the expected numerical difficulty
- Stiff systems include condition numbers ranging from 1e5 to 1e7
- Matrix diagnostic information is provided in comments

